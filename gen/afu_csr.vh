// Code generated by afu_csr_gen


`ifndef AFU_CSR_VH
`define AFU_CSR_VH

localparam ADDR_AFU_DSM_BASEL           = 16'h8a00;
localparam ADDR_AFU_DSM_BASEH           = 16'h8a04;
localparam ADDR_AFU_CNTXT_BASEL         = 16'h8a08;
localparam ADDR_AFU_CNTXT_BASEH         = 16'h8a0c;
localparam ADDR_AFU_EN                  = 16'h8a10;
localparam ADDR_DOORBELL                = 16'h8a14;
localparam ADDR_READ_BUFFER_LINES       = 16'h8a18;
localparam ADDR_READ_BUFFER_BASEL       = 16'h8a1c;
localparam ADDR_READ_BUFFER_BASEH       = 16'h8a20;
localparam ADDR_WRITE_BUFFER_BASEL      = 16'h8a24;
localparam ADDR_WRITE_BUFFER_BASEH      = 16'h8a28;
localparam ADDR_UPDATE_DSM              = 16'h8a2c;
localparam ADDR_PLL_RESET               = 16'h8a30;
localparam ADDR_LOAD_WEIGHTS            = 16'h8a34;
localparam ADDR_NUM_CL_PER_FILTER       = 16'h8a38;
localparam ADDR_NUM_FILTERS             = 16'h8a3c;
localparam ADDR_MAX_WEIGHT_BUFFER_ADDR  = 16'h8a40;
localparam ADDR_LOAD_IMAGES             = 16'h8a44;
localparam ADDR_WRITE_FENCE             = 16'h8a48;

typedef struct
  {
   logic        afu_dsm_base_valid;
   logic [63:0] afu_dsm_base;
   logic        afu_cntxt_base_valid;
   logic [63:0] afu_cntxt_base;
   logic        afu_en;
   logic [31:0] doorbell;
   logic [31:0] read_buffer_lines;
   logic [63:0] read_buffer_base;
   logic [63:0] write_buffer_base;
   logic [31:0] update_dsm;
   logic        pll_reset;
   logic        load_weights;
   logic [7:0]  num_cl_per_filter;
   logic [15:0] num_filters;
   logic [15:0] max_weight_buffer_addr;
   logic        load_images;
   logic        write_fence;
   logic        reset_doorbell;
   logic        reset_update_dsm;
   } afu_csr_t;

`endif